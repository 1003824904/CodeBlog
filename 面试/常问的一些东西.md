# 常见面试题（持续更新）
这里做个记录，记录下来我经常问或者是经常见到的面试题

## JavaScript
1. Q: 介绍`call, apply, bind`的区别
   A: 初级回答： 

  首先我们先了解一下相同点： 这三个函数都可以改变`this`的指向

  区别: 
  - `apply(this, [...args])`第二个参数接受的是`数组`，会立即执行
  - `call(this, arg1,arg2,...args)`第二个参数接受的是`以逗号分割的参数列表`，会立即执行
  - `bind(this, arg1,arg2,...args)` 第二个参数接受的是`以逗号分割的参数列表`， 不会立即执行而是**返回一个原函数的拷贝，并拥有指定的`this`值和初始参数。**

  进阶：如何手动的实现`call` ?

  原理其实3步就能解决
  1. 把函数变成`object`的一个属性
  2. 执行`object`下的这个函数
  3. 删除这个属性

  代码实现
  ```js
  Function.prototype.call = (context = window, ...args) => {
    // context 是null的时候指向window
    context.fn = this // 第一步
    let result = context.fn(...args) // 第二步
    delete context.fn // 第三步
    return result
  }
  ```

  实现`apply`基本是一个原理
  ```js
  Function.prototype.apply = (context = window, args) => {
    // args不展开 直接就是一个数组
    context.fn = this // 第一步
    let result = context.fn(...args) //第二步
    delete context.fn // 第三步
    return result 
  }
  ```

  实现bind
  ```js
  Function.prototype.bind = (context, ...rest) => {
    let self =this
    return function F(...args) {
      // 因为" bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效"
      // 如果是 new 的，则不要之前的 context 啦
      if(this instance of F) {
        return self(...rest, ...args)
      }
      // 返回拼接完之后的函数
      return self.apply(context,rest.concat(args))
    }
  }
  ```

2. `new`的实现 ？
3. 
## CSS/HTML

1. Q: 表单可以跨域吗 ?

A: `form`表单是可以跨域的。

浏览器遵从同源策略，限制ajax跨域的原因在于ajax网络请求是可以携带cookie的（通过设置withCredentials为true），比如用户打开了浏览器，登录了weibo.com，然后又打开了百度首页，这时候百度首页内的js，向weibo.com用withCredentials为true的ajax方式提交一个post请求，是会携带浏览器和weibo.com之间的cookie的，所以浏览器就默认禁止了ajax跨域，服务端必须设置CORS才可以。

而form提交**是不会携带cookie的**，你也没办法设置一个hidden的表单项，然后通过js拿到其他domain的cookie，**因为cookie是基于域的，无法访问其他域的cookie，所以浏览器认为form提交到某个域**，是无法利用浏览器和这个域之间建立的`cookie`和`cookie`中的`session`的，故而，浏览器没有限制表单提交的跨域问题。



## Node

## Vue

## Typescript