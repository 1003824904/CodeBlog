# js中的内存

关于内存，就当是进阶的必经之路。不了解的话不会有什么影响，但是掌握了之后对以后的服务端开发的帮助效果很显著（装起β来也是一套一套的😁）。

## 什么是内存？

> 计算机内存是一种利用半导体技术做成的电子设备，用来存储数据。电子电路的数据是以二进制的方式存储，存储器的每一个存储单元称做记忆元。

上面是`Google`给出的网络定义。 我的理解比较简单，我个人对语言中的内存认为就是`用来存储变量的空间，变量占用内存越小，计算机计算能力就越强。`，性能和内存是有紧密联系的。

### 内存生命周期

这个东西不分语言，都是一致。

1. 分配内存
2. 使用内存（读/写操作）
3. 释放/归还 内存

## js引擎如何使用内存空间

 `JavaScript`的数据类型也分为两大类， 分别是**基本数据类型**和**引用数据类型**, 这两种数据类型在内存中分别以**堆**和**栈**的形式存储。下面先说这两种东西

### 栈内存(stack) 

JS中的基础数据类型(`number、string、null、boolean、undefiend、symbol`)，这些值都有固定的大小，往往都保存在栈内存中（闭包除外），由**系统自动分配存储空间**。我们**可以直接操作保存在栈内存空间的值**，因此基础数据类型都是按值访问数据在栈内存中的存储与使用方式类似于数据结构中的堆栈数据结构，遵循**后进先出(LIFO)**的原则。

栈的存取方式就像是乒乓球盒子一样，处于盒子中最顶层的乒乓球5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。这就是栈空间**先进后出，后进先出**的特点。可以看下图

![stack](./stack.png 'stack')

<small>图片非原创，取自[这篇文章](https://juejin.im/post/5c8a065c6fb9a049de6e3f2f#heading-1)</small>

### 堆内存(heap)

JS中的引用数据类型(`Object、Array、Date、RegExp、Function 等`)的值是保存在堆内存中的对象， 这些**值大小不固定**。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。也可以理解为我们通过引用中的地址来访问堆内存中的实际值。

堆数据结构是一种树状结构。它的存取数据的方式，则与书架与书非常相似。比如我们只要知道书的名字，就可以对应的取下来，类似于`JSON`对象中的`key-value`。就像下面一样

![heap](./heap.png 'heap')


### 栈和堆的区别

通过以下的代码我们来理解一下两者的区别
```js
var a1 = 0;   // 变量对象
var a2 = 'this is string'; // 变量对象
var a3 = null; // 变量对象

var b = { m: 20 }; // 变量b存在于变量对象中，{m: 20} 作为对象存在于堆内存中
var c = [1, 2, 3]; // 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中
```

网友总结的很好了， 一张图就能弄明白变量对象(保存在栈中)与堆内存。

![heap](./heap01.png 'heap')

在这里我们主要要了解的是**数据复制**的不同。

在**变量对象**中的数据发生复制行为时，系统会自动为新的变量分配一个新值。如果是当前数据是**基础数据类型**， 那么会在栈中开辟一段新的内存地址用来存储。实际的旧变量和新变量
不会相互影响。

如果值是引用类型，那么同样也会在开辟新的内存， 但是不同的是这里存放的是引用类型的一个地址指针，而且和旧变量指向的是堆内存中的同一个具体对象。所以他们操作的也是同一个对象。也就是说：**尽管他们相互独立，但是在变量对象中访问到的具体对象实际上是同一个。**。就像下图所描述

![heap](./heap02.png 'heap')

在javascript中通过`=`，`Object.asssign()`等操作的对象复制，**复制的仅仅是引用类型在堆中的地址指针，而不是真正的值**。这就是**浅拷贝**。那么同理我们就可以通过改变引用类型的地址指针来实现我们的**深拷贝**, 具体方法有很多。这里不深入讨论


## 垃圾回收（GC）

这里主要引用`MDN`的介绍

垃圾回收指的是当一个变量不再被引用或者使用的时候就释放它所占据的内存空间。

> 垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。                      --来自[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)


### 引用计数垃圾收集

> 这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。

下面是`MDN`的实例代码
```js
var o = { 
  a: {     // 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o 很显然，没有一个可以被垃圾收集
    b:2
  }
}; 

var o2 = o; // o2变量是第二个对“这个对象”的引用

o = 1;      // 现在，“这个对象”的原始引用o被o2替换了

var oa = o2.a; // 引用“这个对象”的a属性  现在，“这个对象”有两个引用了，一个是o2，一个是oa

o2 = "yo"; // 最初的对象现在已经是零引用了
           // 他可以被垃圾回收了
           // 然而它的属性a的对象还在被oa引用，所以还不能回收

oa = null; // a属性的那个对象现在也是零引用了 它可以被垃圾回收了
```

但是该算法有个限制：**无法处理循环引用。**在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。

举个简单的例子

```js
var div;
window.onload = function(){
  div = document.getElementById("myDivElement");
  // 创建循环引用
  div.circularReference = div;
  // 加入大量的数据
  div.lotsOfData = new Array(10000).join("*");

  // 如果circularReference 没有显示的移除或者设为null， 那么这个对象总是且至少有一个引用，并将一直保持在内存里的 DOM 元素，即使其从DOM 树中删去了
  // 而且lotsOfData这个海量数据所占有的内存将不会被释放。
}
```

### 标记-清除算法

这个算法把**对象是否不再需要**简化定义为**对象是否可以获得**

> 这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。

这个算法比前一个要好，因为**有零引用的对**总是**不可获得**的，但是相反却不一定，参考“循环引用”。

简单的理解就是标记-清除算法通过从`root`开始为每一个对象进行标记，所有的根都被检查和标记成活跃的（不是垃圾），所有的子变量也被递归检查。所有可能从根元素到达的都不被认为是垃圾。在每次定期标记的时候：所有没有被标记成活跃的内存都被认为是垃圾。垃圾回收器就可以释放内存并且把内存还给操作系统。

> 从2012年起，所有现代浏览器都使用了标记-清除垃圾回收算法。所有对JavaScript垃圾回收算法的改进都是基于标记-清除算法的改进，**并没有改进标记-清除算法本身和它对“对象是否不再需要”的简化定义。**


## 内存泄露

这个很简单，就是不再用到的内存，没有及时释放，就叫做**内存泄漏（memory leak）**

引起的主要问题有下面这些

- 意外的全局变量
  
  比如下面这些情况
  ```js
  // 1
  function foo(arg) {
    bar = "some text"; // 就等同于 window.bar = "some text";
  }
  // 2
  function foo() {
      this.var1 = "potential accidental global";
  }
  foo();
  // Foo作为函数调用，this指向全局变量(window)  var1就被创建了出来
  ```
- 被遗忘的定时器或者回调
- 闭包（本身不会造成内存泄露，程序写错了才会造成内存泄漏或者闭包过多很容易导致内存泄漏。）,下面是一种造成内存泄漏的写法
  
  ```js
  var theThing = null;

  var replaceThing = function () {

    var originalThing = theThing;
    var unused = function () {
      if (originalThing) // 引用'originalThing'
        console.log("hi");
    };

    theThing = {
      longStr: new Array(1000000).join('*'),
      someMethod: function () {
        console.log("message");
      }
    };
  };

  setInterval(replaceThing, 1000);
  ```
  每次`replaceThing`被调用，`theThing`获得一个包含大数组和新的闭包(`someMethod`)的对象。同时，变量`unused`保持了一个引用`originalThing`(**theThing是上次调用replaceThing生成的值**)的闭包。已经有点困惑了吧？最重要的事情是**一旦为同一父域中的作用域产生闭包，则该作用域是共享的。**

  这里，作用域产生了闭包，`someMethod`和`unused`共享这个闭包中的内存。`unused`引用了`originalThing`。尽管`unused`不会被使用，`someMethod`可以通过`theThing`来使用`replaceThing`作用域外的变量（例如某些全局的）。而且`someMethod`和`unused`有共同的闭包作用域，`unused`对`originalThing`的引用强制`oriiginalThing`保持激活状态(两个闭包共享整个作用域)。这阻止了它的回收。
- `DOM`外引用

  比如我们在数据结构里存储DOM节点时
  ```js
  var elements = {
    button: document.getElementById('button'),
    image: document.getElementById('image')
  };

  function doStuff() {
      image.src = 'http://example.com/image_name.png';
  }

  function removeImage() {
      //image是body元素的子节点
      document.body.removeChild(document.getElementById('image'));

      //这个时候我们在全局的elements对象里仍然有一个对#button的引用。
      //换句话说，buttom元素仍然在内存中而且不能被回收。
  }
  ```

# 总结

参考资料

- [内存管理](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)
- [容易被遗忘的前端基础：JavaScript 内存详解](https://juejin.im/post/5c8a065c6fb9a049de6e3f2f#heading-1)
- [JS进阶系列之内存空间](https://www.cnblogs.com/mcray/p/7002089.html)
- [【译】JavaScript是如何工作的：内存管理 + 如何处理4个常见的内存泄露](https://segmentfault.com/a/1190000011411121)

如果觉得有帮助的得话给个⭐吧😁
